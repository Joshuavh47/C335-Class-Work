
# Phase 1

For this phase, I opened the bomb binary file in visual mode in r2, then I used `s sym.phase_1` to jump to the `phase_1` method. I noticed that there was a `leaq` command being called, which placed the solution to the phase into the `%rsi` pointer which then called `sym.strings_not_equal` in order to compare the string that got pushed to `%rsi` (the correct answer) to the string entered by the user. Thus, the string that is stored in `%rsi` is the answer to phase 1, which is "There are rumors on the internets."

# Phase 2

For this phase, it is seen that there are 2 variables initialized through the `%rsp` registry, one with a displacement of 4 bytes, and the other with a displacement of 10 bytes. The program calls a method that checks that there are 6 integers entered either by the user or through a text file, then sets the `%rsp` and `%rsi` stack registries so that if there are 6 integers, the detonation method is not called and the number amount checker returns instead. The `%rsp` registry is set so that the hex dump gives `(num1)00 0000 (num2)00 0000 (num3)00 0000 (num4)00 0000 (num5)00 0000 (num6)00 0000`. If the first number is not 0 (`num1 !=00` or 0 in decimal,) the program jumps to the `explode_bomb` call (triggering the detonation) because of the `cmpl` call comparing the literal `$0` with the 0 byte of `%rsp`. The program also checks for the second number to be equal to 1 as seen in the `cmpl $1, var_34` (which is the variable equal to `%rsp` shifted by 4 bytes,) and if it evaluates to `true`, it skips the detonation call. If this is the case, it skips this jump (and bomb detonation) and copies `%rsp` to `%rbx` with a `movq` command.  Then, the program sets `%rbp` to the variable that was equal to `%rsp+0x10` (`%rsp` shifted over 16 bytes.) This is where the algorithm sets in- the program enters a loop where it shifts `$rbx` by 4 bytes (`addl $4, %rbx`.) Then, adds the two prior integers to `%eax` (the return registry,) then doubles it (in the first iteration of the loop it is (0+1)*2 because as of now, we know that the first numbers must be 0 and 1 to fit this algorithm.) It then compares this number (`%eax`) to the 8th byte of `%rbx` (the next integer in the pattern) and returns when they are equal. Thus, the program starts with (0+1)*2=2, then (1+2)*2=6, then (2+6)*2=16, and finally (6+16)*2=44. So, when the program gets to the end of the loop and the code is entered correctly, `%eax` will be 44, and the last integer will be 44, so the program will return. Therefore, the 6 integers are 0, 1, 2, 6, 16, and 44.

# Phase 3

For this phase, the program calls the `string_length` method, which checks if the length of the input String (stored in `%rbp`) is equal to 10. If this is the case, it jumps over the `explode_bomb` method. Then, the program establishes an integer array of 10 numbers in the `%rsp` registry [7, 12, 11, 3, 6, 8, 13, 1, 9, 15]. It separates these values by 4 bytes each, as that is the size of an integer value in c. It then sets up the beginning of a loop. It does this by establishing the `%eax`, which is the counter, and sets it equal to 0. It also sets another registry (`%esi`) which I thought of as a boolean variable that is initially set to `true`. Then, it sets `%r9` equal to the String "B.Disraeli", and copies `%rsp` (the integer array) to `%r8`. Then, it clears out `%edi`/`%rdi` by setting it equal to 0 before the loop. During the loop, it takes the **i**th character of `%r9` (the given String) and moves it into `%ecx`. Then, it takes the **i**th value of `%rbp` (the user input String) and stores it in `%edx`. It then xor's this with the **i**th value of the integer array (`%r8`, formerly `%rsp`) with the previous value of `%edx` (the **i**th character of the user input String.) It then compares the two, and if they are not equal, it moves the value of `%edi` to `%esi`. This is important because in order to satisfy the return conditions of the loop and not trigger the bomb, `%esi` must remain equal to 1 (`true`). If this move occurs, it will set `%esi` equal to 0 because that is the value of `%edi`. Therefore, in order to successfully return this method and not trigger an explosion, `%edx` must equal `%ecx` for every index in all of the respective arrays. In order to solve this challenge, you must work backwards. Due to the properties of the xor function, a^b=c, a^c=b, and vice versa. Therefore, to get the original letters, you must xor each number in the integer array (`%rsp`/`%r8`) with the integer representation of each character in the given String (`%r9`). If you turn each of the resulting numbers back to characters, you get **E"Ojuzldef**, which is the correct input String for phase 3.

# Phase 4

For this phase, the program sets `%eax` equal to 0, then uses this register to store the output of the `scanf` method that is called. If there are less than 3 arguments read by `scanf` (denoted by the `cmpl $2, %eax`), the program jumps to the explosion method. After this, it checks if `var_ch` is equal to 7 (I assume that this variable stores the first number of user input given that the variable spacing is 1 byte between the first and middle, and 4 bytes between the middle and last because chars are 1 byte long and ints are 4 bytes long). If it is, the jump is bypassed, and the program calculates the correct address to jump to in the switch statement. After the jump occurs, the program moves `$0x6f` (decimal: 111 or the letter 'o') onto `%eax` (this is important later), then compares `$0x122` (which is 290 in decimal) and `8(%rsp)` (which is exactly where we established `var_10h`, the variable that stored the second number/last variable of user input). So this is comparing if the last number is equal to 290, and if it is, it jumps over the explosion call. Then, it compares `7(%rsp)` (which is where `var_11h`, the variable that stores the char from user input, is located) to `%al` (which is the first portion of `%eax`/`%rax`, and was why moving `$0x6f` onto  `%eax` was important). If we use `?vi al` at this point in the program, we can see that the program checks if that char variable is equal to 111, or in char form, 'o'. Thus, if we put all the pieces together, the final answer to phase 4 is "7 o 290".

# Phase 5

For this phase, the program takes 2 different integers. The first one is stored in `var_ch` at `%rsp+0xc` and the second one is stored in `var_10h` at `%rsp+0x8`. First, the program ensures that there are 2 numbers entered. If there are not, it triggers an explosion. If there are the correct amount of numbers, the program jumps to a part of the program that subtracts 8 from the first number and checks if it is under 7. If it is not, it triggers an explosion. If it is less than 7, it jumps to a call for `func5`. In this function, there is a loop that adds the number to a variable, then subtracts 2. The program checks if this resulting number is equal to 56. I wrote a small java program that simulates this, and found that the number that satisfies this is 14. This also works because 14-8<7, which satisfies the other condition of the program. The program compares if the resulting total from repetitively subtracting 2 and totaling the first number is 56, and if it is, it jumps over the explosion call. Then, it checks if the second number is 56 (`$0x38`), and if it isn't it jumps to an explosion call. If it is, it jumps to the return instruction. Therefore, the answer to phase 5 is "14 56".
